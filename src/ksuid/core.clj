(ns ksuid.core
  (:require clojure.string)
  (:require [ksuid.base62 :as base62]))


(comment
  "Binary KSUIDs are 20-bytes: a 32-bit unsigned integer UTC timestamp and a 128-bit randomly generated payload. The timestamp uses big-endian encoding, to support lexicographic sorting. The timestamp epoch is adjusted to May 13th, 2014, providing over 100 years of life. The payload is generated by a cryptographically-strong pseudorandom number generator.")

;; KSUID's epoch starts more recently so that the 32-bit number space gives a
;; significantly higher useful lifetime of around 136 years from March 2017.
;; This number (14e8) was picked to be easy to remember.
(def epoch-stamp 1400000000)

(def timestamp-byte-length 4)
(def payload-byte-length 16)
(def byte-length (+ timestamp-byte-length payload-byte-length))
;; KSUID always have a length of 27
(def encoding-length 27)

(defn get-epoch-seconds []
  (.getEpochSecond (java.time.Instant/now)))

(defn- to-corrected-timestamp [timestamp]
  (- timestamp epoch-stamp))

(defn- generate-random-bytes
  "Generate a cryptographically strong random byte-array"
  [size]
  (let [bytes (byte-array size)]
    (.nextBytes (java.security.SecureRandom.) bytes)
    bytes))

(defn- leftpad
  [s length char]
  (let [length-to-pad (- length (count s))]
    (str (clojure.string/join (repeat length-to-pad char)) s)))


(defn- new-bytes
  "Create a new KSUID in byte-array. 
   Use this if you only care about the underlying byte-array,
   otherwise use ksuid()."
  [timestamp]
  (let [timestamp timestamp
        payload (generate-random-bytes 16)]
    (-> (java.nio.ByteBuffer/allocate byte-length)
        (.putInt timestamp)
        (.put payload)
        (.array))))


(defn- encode-ksuid
  [bytes]
  (leftpad (base62/encode-bytes bytes) encoding-length "0"))


(defn new-random
  "Create a new KSUID."
  ([]
   (let [timestamp (to-corrected-timestamp (get-epoch-seconds))
         ksuid-bytes (new-bytes  timestamp)]
     constantly {:string (encode-ksuid ksuid-bytes)
                 :bytes ksuid-bytes
                 :timestamp timestamp})))

(defn new-random-with-time
  ([time-instant]
   (throw (ex-info "Not Implemented" {}))))

(defn from-parts
  [timestamp payload]
  (throw (ex-info "Not Implemented" {})))

(defn from-bytes
  [timestamp payload]
  (throw (ex-info "Not Implemented" {})))

(defn valid?
  "Check if a string is a valid KSUID."
  [ksuid]
  ;; TODO: (regex) match only base62 characters)
  (cond
    (not= (count ksuid) encoding-length) false
    (not (base62/base62? ksuid)) false
    :else true))

(comment
  (new-random))
